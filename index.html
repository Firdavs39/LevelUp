<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Интерфейс Прокачки Атрибутов</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Condensed:wght@700&display=swap" rel="stylesheet">
    <style>
        html, body {
            height: 100%;
            overflow: hidden;
        }
        body {
            font-family: 'Inter', sans-serif;
            color: #CBD5E1;
            margin: 0;
            position: relative;
            background-color: #02030A;
        }
        #starryBackground {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: -1;
        }
        #loadingIndicator {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #93C5FD;
            font-size: 1.5rem; z-index: 1000; display: none;
            text-align: center;
            background-color: rgba(0,0,0,0.7); padding: 15px 25px; border-radius: 12px;
        }

        .control-button-group {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: row;
            gap: 12px;
            z-index: 1003; /* Above modals when closed, modals will have higher z-index when open */
        }

        .control-button {
            background-color: #374151;
            color: #E5E7EB;
            border: none;
            border-radius: 50%;
            width: 48px;
            height: 48px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.3s ease;
        }
        .control-button:hover {
            background-color: #4B5563;
        }
        .control-button svg {
            width: 24px; /* Standardized icon size */
            height: 24px;
        }

        /* Modal Base Styles (for all modals: attributes and timer) */
        .modal-backdrop {
            position: fixed;
            inset: 0;
            background-color: rgba(10, 20, 40, 0.6);
            backdrop-filter: blur(5px);
            display: none; /* Hidden by default */
            align-items: center;
            justify-content: center;
            z-index: 2000; /* High z-index */
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        .modal-backdrop.open {
            display: flex;
            opacity: 1;
        }
        .modal-content-box {
            background-color: #E2E8F0; /* Neumorphic light background */
            color: #1E293B; /* Dark text for contrast */
            padding: 25px 30px;
            border-radius: 16px;
            box-shadow: 8px 8px 16px #c1c9d2, -8px -8px 16px #ffffff; /* Neumorphic outer shadow */
            width: 90vw;
            max-width: 420px; /* Slightly wider for attribute content */
            text-align: center;
            display: flex;
            flex-direction: column;
            max-height: 85vh; /* Ensure modal fits on screen */
        }
        .modal-header {
            font-size: 1.5rem; /* Larger header */
            font-weight: 700;
            color: #334155; /* Darker slate for header */
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #CBD5E1;
        }
        .modal-body-scrollable { /* This will contain the lists and inputs */
            overflow-y: auto;
            flex-grow: 1; /* Allows this area to expand and fill available space */
            min-height: 0; /* Crucial for flexbox children to scroll correctly */
            padding-right: 5px; /* Space for scrollbar */
            margin-right: -5px; /* Counteract padding for full width */
            scrollbar-width: thin;
            scrollbar-color: #9ca3af #E2E8F0;
        }
        .modal-body-scrollable::-webkit-scrollbar { width: 8px; }
        .modal-body-scrollable::-webkit-scrollbar-track { background: #E2E8F0; border-radius: 10px; }
        .modal-body-scrollable::-webkit-scrollbar-thumb { background-color: #9ca3af; border-radius: 10px; border: 2px solid #E2E8F0; }

        .modal-footer {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #CBD5E1;
        }
        .modal-close-btn { /* Common style for close buttons in modals */
            padding: 10px 20px;
            border-radius: 10px;
            font-weight: 600;
            font-size: 0.9rem;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 3px 3px 6px #c1c9d2, -3px -3px 6px #ffffff;
            color: #334155;
            background-color: #E2E8F0;
            width: 100%;
        }
        .modal-close-btn:hover {
            color: #0EA5E9;
            box-shadow: 2px 2px 5px #c1c9d2, -2px -2px 5px #ffffff;
        }
        .modal-close-btn:active {
            box-shadow: inset 3px 3px 6px #c1c9d2, inset -3px -3px 6px #ffffff;
        }


        /* Attribute specific modal content inherits general modal styles */
        /* Styles for .attribute-buttons-container, .attribute-button, etc. will apply within modals */

        .level-rank-display {
            text-align: center;
            margin-bottom: 10px;
            font-size: 0.9rem;
            font-weight: 600;
            color: #4A5568;
            flex-shrink: 0;
        }
        .level-rank-display .rank-E { color: #718096; }
        .level-rank-display .rank-D { color: #48BB78; }
        .level-rank-display .rank-C { color: #4299E1; }
        .level-rank-display .rank-B { color: #9F7AEA; }
        .level-rank-display .rank-A { color: #ED8936; }
        .level-rank-display .rank-S { color: #E53E3E; }

        @media (min-width: 768px) {
            .level-rank-display {
                font-size: 1rem;
                margin-bottom: 16px;
            }
        }

        .attribute-buttons-container { /* This might be removed if attributes are directly in modals */
            flex-shrink: 0;
            margin-bottom: 10px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        @media (min-width: 768px) {
            .attribute-buttons-container {
                margin-bottom: 16px;
            }
        }

        .attribute-button { /* These were for switching tabs, may not be needed if each attribute is a modal */
            background-color: #E2E8F0; color: #334155; border: 1px solid transparent;
            transition: all 0.2s ease-in-out; flex-shrink: 0; font-weight: 600;
            text-transform: none; letter-spacing: 0.02em;
            border-radius: 10px;
            padding: 10px 12px;
            font-size: 0.85rem;
            box-shadow: 3px 3px 6px #c1c9d2, -3px -3px 6px #ffffff;
            text-align: center;
            width: 100%;
        }
        @media (min-width: 768px) {
            .attribute-button {
                padding: 14px 18px;
                margin-bottom: 10px !important;
                font-size: 1rem;
                letter-spacing: 0.025em;
                border-radius: 12px;
                box-shadow: 4px 4px 8px #c1c9d2, -4px -4px 8px #ffffff;
            }
        }
        .attribute-button:hover { color: #0EA5E9; box-shadow: 2px 2px 5px #c1c9d2, -2px -2px 5px #ffffff;}
        .attribute-button.active-attribute {
            color: #0EA5E9;
            box-shadow: inset 3px 3px 6px #c1c9d2, inset -3px -3px 6px #ffffff;
            font-weight: 700;
        }
        #canvasContainer {
            z-index: 0;
            flex-grow: 1;
            width: 100%;
            height: 100%;
            position:relative;
        }
        canvas { display: block; width: 100%; height: 100%;}

        .attribute-content-area { /* Used inside modals now */
            padding-top: 10px; /* Add some padding at the top of the scrollable area */
        }
        /* .attribute-content-area.active { display: block; } No longer needed as modals control visibility */

        .content-header { /* Headers for task sections within modals */
            font-size: 1.1rem;
            font-weight: 600; color: #475569;
            margin-bottom: 10px;
            padding-bottom: 6px;
            border-bottom: 1px solid #CBD5E1; text-align: center;
            flex-shrink: 0;
        }
        @media (min-width: 768px) {
            .content-header {
                font-size: 1.3rem;
                margin-bottom: 18px;
                padding-bottom: 8px;
            }
        }
        .task-item {
            background-color: #F1F5F9; color: #1E293B;
            padding: 8px 10px;
            margin-bottom: 8px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            transition: all 0.2s ease-in-out;
            box-shadow: 2px 2px 4px #d1d9e6, -2px -2px 4px #ffffff;
        }
        .task-item span.task-text {
            font-size: 0.85rem;
            overflow-wrap: break-word;
            word-break: break-word;
            text-align: left;
            flex-grow: 1;
            margin-bottom: 6px;
        }

        @media (min-width: 768px) {
            .task-item {
                flex-direction: row;
                justify-content: space-between;
                align-items: center;
                padding: 10px 15px;
            }
            .task-item span.task-text {
                font-size: 1rem;
                margin-bottom: 0;
                margin-right: 8px;
            }
        }


        .memory-item {
            background-color: #F1F5F9; color: #1E293B;
            padding: 8px 12px;
            margin-bottom: 8px;
            border-radius: 8px;
            display: flex; justify-content: space-between; align-items: center;
            transition: all 0.2s ease-in-out;
            box-shadow: 2px 2px 4px #d1d9e6, -2px -2px 4px #ffffff;
        }
        .memory-item span.flex-grow {
            font-size: 0.85rem;
        }
        @media (min-width: 768px) {
             .memory-item { padding: 10px 15px; }
             .memory-item span.flex-grow { font-size: 1rem; }
        }

        .task-item:hover, .memory-item:hover { box-shadow: 1px 1px 3px #d1d9e6, -1px -1px 3px #ffffff; }

        .task-controls {
            display: flex;
            align-items: center;
            width: auto;
            justify-content: flex-end;
            flex-shrink: 0;
        }


        .task-counter-group { display: flex; align-items: center; }
        .task-counter-input {
            width: 40px;
            text-align: center;
            font-weight: 600;
            font-size: 0.8rem;
            color: #0EA5E9;
            background-color: #E2E8F0;
            border: 1px solid #CBD5E1;
            border-radius: 5px;
            margin: 0 4px;
            padding: 1px 2px;
            box-shadow: inset 1px 1px 2px #c1c9d2, inset -1px -1px 2px #ffffff;
        }
        @media (min-width: 768px) {
            .task-counter-input {
                width: 60px;
                font-size: 1em;
                margin: 0 8px;
                padding: 2px 4px;
                border-radius: 6px;
            }
        }
        .task-counter-input:focus {
            outline: none;
            border-color: #93C5FD;
            box-shadow: inset 1px 1px 2px #c1c9d2, inset -1px -1px 2px #ffffff, 0 0 0 2px #93C5FD;
        }
        .task-counter {
             margin: 0 10px; font-weight: 600; font-size: 1em; color: #0EA5E9;
        }
        .plus-btn, .delete-item-btn, .delete-task-btn {
            background-color: #E2E8F0; color: #475569; border-radius: 6px;
            width: 24px; height: 24px; font-size: 14px; line-height: 24px;
            text-align: center;
            box-shadow: 1px 1px 3px #c1c9d2, -1px -1px 3px #ffffff;
            margin-left: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding:0;
        }

        @media (min-width: 768px) {
            .plus-btn, .delete-item-btn, .delete-task-btn {
                width: 28px; height: 28px; font-size: 18px; line-height: 28px;
                margin-left: 6px;
                border-radius: 8px;
            }
        }
        .plus-btn:hover { color: #0284C7; box-shadow: inset 1px 1px 2px #c1c9d2, inset -1px -1px 2px #ffffff; }
        .delete-item-btn, .delete-task-btn { color: #DC2626; }
        .delete-item-btn:hover, .delete-task-btn:hover { color: #B91C1C; box-shadow: inset 1px 1px 2px #c1c9d2, inset -1px -1px 2px #ffffff; }


        input[type="text"].task-input {
            padding: 6px 8px;
            font-size: 0.9rem;
            border-radius: 6px; color: #1E293B;
            flex-grow: 1; margin-right: 6px; background-color: #E2E8F0;
            border: none; box-shadow: inset 2px 2px 5px #c1c9d2, inset -2px -2px 5px #ffffff;
        }
        @media (min-width: 768px) {
            input[type="text"].task-input {
                padding: 10px 12px;
                font-size: 1rem;
                border-radius: 8px;
                margin-right: 8px;
            }
        }
         input[type="text"].task-input:focus {
            outline: none;
            box-shadow: inset 3px 3px 7px #c1c9d2, inset -3px -3px 7px #ffffff, 0 0 0 2px #93C5FD;
        }
        .add-task-btn {
            padding: 6px 10px;
            font-size: 0.9rem;
            border-radius: 6px; font-weight: 600; text-transform: none;
            color: #334155; background-color: #E2E8F0; border: none;
            box-shadow: 2px 2px 4px #c1c9d2, -2px -2px 4px #ffffff;
            flex-shrink: 0;
        }
         @media (min-width: 768px) {
            .add-task-btn {
                padding: 10px 15px;
                font-size: 1rem;
                border-radius: 8px;
                box-shadow: 3px 3px 6px #c1c9d2, -3px -3px 6px #ffffff;
            }
        }
        .add-task-btn:hover { color: #0EA5E9; box-shadow: 1px 1px 3px #d1d9e6, -1px -1px 3px #ffffff;}
        .intellect-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-bottom: 10px;
        }
        .intellect-tabs button {
            padding: 6px 8px;
            font-size: 0.75rem;
            border-radius: 6px; background-color: #CBD5E1;
            color: #475569; border: none; cursor: pointer;
            box-shadow: 2px 2px 4px #b8c1cb, -2px -2px 4px #ffffff;
            font-weight: 500;
        }
        .intellect-tabs button.active-tab {
            background-color: #E2E8F0; color: #0EA5E9;
            box-shadow: inset 2px 2px 4px #c1c9d2, inset -2px -2px 4px #ffffff;
            font-weight: 600;
        }
        .intellect-tabs button:hover { color: #0EA5E9; }
        .intellect-tab-content { display: none; margin-top: 8px; }
        .intellect-tab-content.active { display: block; }

        .app-wrapper {
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        #messageArea { /* Updated for global positioning */
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: rgba(17, 24, 39, 0.8); /* Darker, semi-transparent */
            backdrop-filter: blur(3px);
            color: #9ca3af; /* Lighter text for dark bg */
            padding: 8px 15px;
            text-align: center;
            font-size: 0.875rem;
            z-index: 1001; /* Below modals but above canvas */
            transition: opacity 0.3s ease, transform 0.3s ease;
            opacity: 0; /* Hidden by default, shown by JS */
            transform: translateY(100%);
        }
        #messageArea.show {
            opacity: 1;
            transform: translateY(0);
        }


        #levelUpText {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.5);
            font-family: 'Roboto Condensed', sans-serif;
            font-size: 3rem;
            font-weight: 700;
            color: #FFF;
            text-shadow:
                0 0 5px #FFF,
                0 0 10px #FFF,
                0 0 15px #FFF,
                0 0 20px #00A8FF,
                0 0 35px #00A8FF,
                0 0 40px #00A8FF,
                0 0 50px #00A8FF,
                0 0 75px #00A8FF;
            opacity: 0;
            transition: transform 0.4s cubic-bezier(0.68, -0.55, 0.27, 1.55), opacity 0.4s ease-out;
            pointer-events: none;
            z-index: 990;
        }
        #levelUpText.show {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }
         @media (min-width: 768px) {
            #levelUpText {
                font-size: 4.5rem;
                 top: 50%;
            }
        }

        /* Global Timer Modal Styles */
        #globalTimerModal .timer-modal-content { /* Re-using .modal-content-box */
            background-color: #E2E8F0;
            color: #1E293B;
            padding: 25px 30px;
            border-radius: 16px;
            box-shadow: 8px 8px 16px #c1c9d2, -8px -8px 16px #ffffff;
            width: 90vw;
            max-width: 380px;
            text-align: center;
        }
        .timer-circle-container {
            position: relative;
            width: 180px;
            height: 180px;
            margin: 20px auto;
        }
        .timer-circle-bg, .timer-circle-progress {
            fill: none;
            stroke-width: 14;
        }
        .timer-circle-bg {
            stroke: #d1d9e6;
        }
        .timer-circle-progress {
            stroke: #0EA5E9;
            stroke-linecap: round;
            transform: rotate(-90deg);
            transform-origin: 50% 50%;
            transition: stroke-dashoffset 0.25s linear;
        }
        .timer-modal-time {
            font-size: 2.5rem;
            font-weight: 700;
            color: #1E293B;
            margin-bottom: 20px;
            font-family: 'Roboto Condensed', sans-serif;
        }
        .timer-modal-controls label {
            display: block;
            font-size: 0.85rem;
            font-weight: 500;
            color: #475569;
            margin-bottom: 5px;
        }
        .timer-modal-controls input[type="number"] {
            width: 90px;
            padding: 10px 12px;
            background-color: #E2E8F0;
            border: none;
            color: #1E293B;
            border-radius: 8px;
            text-align: center;
            font-size: 1rem;
            margin-bottom: 20px;
            box-shadow: inset 2px 2px 5px #c1c9d2, inset -2px -2px 5px #ffffff;
        }
        .timer-modal-controls input[type="number"]:focus {
            outline: none;
            box-shadow: inset 3px 3px 7px #c1c9d2, inset -3px -3px 7px #ffffff, 0 0 0 2px #0EA5E980;
        }
        .timer-modal-buttons {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }
        .timer-modal-buttons button {
            flex-grow: 1;
            padding: 12px 15px;
            border-radius: 10px;
            font-weight: 600;
            font-size: 0.9rem;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 3px 3px 6px #c1c9d2, -3px -3px 6px #ffffff;
            color: #334155;
            background-color: #E2E8F0;
        }
        .timer-modal-buttons button:hover {
            color: #0EA5E9;
            box-shadow: 2px 2px 5px #c1c9d2, -2px -2px 5px #ffffff;
        }
        .timer-modal-buttons button:active {
            box-shadow: inset 3px 3px 6px #c1c9d2, inset -3px -3px 6px #ffffff;
        }

        .timer-modal-buttons button.start-timer-btn.running {
            color: #D97706;
        }

    </style>
</head>
<body class="app-wrapper">

    <canvas id="starryBackground"></canvas>

    <div id="canvasContainer" class="flex-grow relative">
        <div id="loadingIndicator">Загрузка 3D модели...</div>
        <div id="levelUpText">УРОВЕНЬ ПОВЫШЕН!</div>
    </div>

    <div class="control-button-group" id="controlButtonGroup">
        <button id="toggleSpiritualModalBtn" class="control-button" title="Духовность">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" d="M9.813 15.904L9 18.75l-.813-2.846a4.5 4.5 0 00-3.09-3.09L1.25 12l2.846-.813a4.5 4.5 0 003.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 003.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 00-3.09 3.09zM18.25 12L17 13.75M17 10.25l1.25-1.5M17 13.75l-1.25-1.5M17 10.25L15.75 12" />
            </svg>
        </button>
        <button id="toggleIntellectModalBtn" class="control-button" title="Интеллект">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                 <path stroke-linecap="round" stroke-linejoin="round" d="M12 6.042A8.967 8.967 0 006 3.75c-1.052 0-2.062.18-3 .512v14.25A8.987 8.987 0 016 18c2.305 0 4.408.867 6 2.292m0-14.25a8.966 8.966 0 016-2.292c1.052 0 2.062.18 3 .512v14.25A8.987 8.987 0 0018 18a8.967 8.967 0 00-6 2.292m0-14.25v14.25" />
            </svg>
        </button>
        <button id="toggleCombatModalBtn" class="control-button" title="Боевые навыки">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                 <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75L11.25 15 15 9.75m-3-7.036A11.959 11.959 0 013.598 6 11.99 11.99 0 003 9.749c0 5.592 3.824 10.29 9 11.623 5.176-1.332 9-6.03 9-11.623 0-1.602-.398-3.126-1.123-4.471A11.959 11.959 0 0118 6.002c-2.474 0-4.786.666-6.702 1.764A11.955 11.955 0 009 12.75z" />
            </svg>
        </button>
        <button id="toggleGlobalTimerBtn" class="control-button" title="Открыть глобальный таймер">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
        </button>
    </div>


    <div id="spiritualModal" class="modal-backdrop">
        <div class="modal-content-box">
            <h3 class="modal-header">Духовность</h3>
            <div id="levelRankDisplaySpiritual" class="level-rank-display">Уровень: 0 (Ранг: E)</div> <div class="modal-body-scrollable">
                <div class="attribute-content-area" style="display: block;"> <h4 class="content-header">Духовные Практики</h4>
                    <div class="flex mb-3"><input type="text" id="newSpiritualTaskInput" class="task-input flex-grow" placeholder="Новая практика..."><button id="addSpiritualTaskBtn" class="add-task-btn ml-2">Добавить</button></div>
                    <div id="spiritualTaskList"></div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-close-btn" data-modal-id="spiritualModal">Закрыть</button>
            </div>
        </div>
    </div>

    <div id="intellectModal" class="modal-backdrop">
        <div class="modal-content-box">
            <h3 class="modal-header">Интеллект</h3>
            <div id="levelRankDisplayIntellect" class="level-rank-display">Уровень: 0 (Ранг: E)</div> <div class="intellect-tabs mb-3"> <button data-tab="memory" class="active-tab">Память</button>
                <button data-tab="analysis">Анализ</button>
                <button data-tab="tafakkur">Тафаккур</button>
            </div>
            <div class="modal-body-scrollable">
                <div id="memoryTabContent" class="intellect-tab-content active attribute-content-area" style="display: block;">
                    <h4 class="text-base md:text-lg font-semibold mb-2 md:mb-3 text-slate-600">Выучить:</h4>
                    <div class="flex mb-2 md:mb-3"><input type="text" id="newMemoryToLearnInput" class="task-input flex-grow" placeholder="Что нужно выучить..."><button id="addMemoryToLearnBtn" class="add-task-btn ml-2">Добавить</button></div>
                    <div id="memoryToLearnList" class="mb-3 md:mb-4"></div>
                    <h4 class="text-base md:text-lg font-semibold mb-2 md:mb-3 text-slate-600">Выучено:</h4>
                    <div class="flex mb-2 md:mb-3"><input type="text" id="newMemoryLearnedInput" class="task-input flex-grow" placeholder="Что уже выучено..."><button id="addMemoryLearnedBtn" class="add-task-btn ml-2">Добавить</button></div>
                    <div id="memoryLearnedList"></div>
                </div>
                <div id="analysisTabContent" class="intellect-tab-content attribute-content-area">
                    <h4 class="text-base md:text-lg font-semibold mb-2 md:mb-3 text-slate-600">Аналитические Задачи:</h4>
                    <div class="flex mb-2 md:mb-3"><input type="text" id="newAnalysisTaskInput" class="task-input flex-grow" placeholder="Новая задача..."><button id="addAnalysisTaskBtn" class="add-task-btn ml-2">Добавить</button></div>
                    <div id="analysisTaskList"></div>
                </div>
                <div id="tafakkurTabContent" class="intellect-tab-content attribute-content-area">
                    <h4 class="text-base md:text-lg font-semibold mb-2 md:mb-3 text-slate-600">Темы для Размышления:</h4>
                    <div class="flex mb-2 md:mb-3"><input type="text" id="newTafakkurTaskInput" class="task-input flex-grow" placeholder="Новая тема..."><button id="addTafakkurTaskBtn" class="add-task-btn ml-2">Добавить</button></div>
                    <div id="tafakkurTaskList"></div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-close-btn" data-modal-id="intellectModal">Закрыть</button>
            </div>
        </div>
    </div>

    <div id="combatModal" class="modal-backdrop">
        <div class="modal-content-box">
            <h3 class="modal-header">Боевые Навыки</h3>
            <div id="levelRankDisplayCombat" class="level-rank-display">Уровень: 0 (Ранг: E)</div> <div class="modal-body-scrollable">
                <div class="attribute-content-area" style="display: block;">
                    <h4 class="content-header">Боевые Тренировки</h4>
                    <div class="flex mb-3"><input type="text" id="newCombatTaskInput" class="task-input flex-grow" placeholder="Новая тренировка..."><button id="addCombatTaskBtn" class="add-task-btn ml-2">Добавить</button></div>
                    <div id="combatTaskList"></div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-close-btn" data-modal-id="combatModal">Закрыть</button>
            </div>
        </div>
    </div>

    <div id="globalTimerModal" class="modal-backdrop">
        <div class="timer-modal-content"> <div class="timer-circle-container">
                <svg width="180" height="180" viewBox="0 0 120 120">
                    <circle class="timer-circle-bg" cx="60" cy="60" r="54"></circle>
                    <circle class="timer-circle-progress" id="globalTimerCircleProgress" cx="60" cy="60" r="54"></circle>
                </svg>
            </div>
            <div class="timer-modal-time" id="globalTimerDisplay">02:00</div>
            <div class="timer-modal-controls">
                <label for="globalTimerDurationInput">Длительность (сек):</label>
                <input type="number" id="globalTimerDurationInput" value="120" min="1">
            </div>
            <div class="timer-modal-buttons">
                <button id="globalTimerStartBtn" class="start-timer-btn">Старт</button>
                <button id="globalTimerResetBtn" class="reset-timer-btn">Сброс</button>
                <button id="globalTimerCloseBtn" class="modal-close-btn" data-modal-id="globalTimerModal">Закрыть</button>
            </div>
        </div>
    </div>

    <div id="messageArea"></div>


    <script>
        // JavaScript code for Attribute Leveling Interface v9.70 (Attribute Modals UI Update)
        console.log("Запуск скрипта. v9.70 (Модальные окна атрибутов, UI Таймера)");
        // --- Global Variables ---
        let scene, camera, renderer, loadedModel, controls;
        let intellectAuraGroup, combatAuraGroup, spiritualAuraGroup, groundImpulseGroup;
        let timerSoundSynth;

        // Global Timer Variables
        let globalTimerIntervalId = null;
        let globalTimerTotalSeconds = 120;
        let globalTimerRemainingSeconds = 120;
        let isGlobalTimerRunning = false;
        const globalTimerCircle = document.getElementById('globalTimerCircleProgress');
        const globalTimerRadius = globalTimerCircle ? globalTimerCircle.r.baseVal.value : 0;
        const globalTimerCircumference = globalTimerRadius * 2 * Math.PI;


        const AURA_BOLT_LIFETIME = 700;
        const AURA_BOLT_COLOR_BASE = new THREE.Color(0x0077FF);
        const AURA_BOLT_COLOR_BRIGHT = new THREE.Color(0x66B2FF);
        const MAX_TOTAL_BOLTS = 50;
        let currentIntellectPoints = 0;

        const FLAME_COLOR_START = new THREE.Color(0xFF4500);
        const FLAME_COLOR_END = new THREE.Color(0xFF8C00);

        const SPIRIT_COLOR = new THREE.Color(0xFFFFFF);

        const IMPULSE_COLOR = new THREE.Color(0x44AAFF);
        const IMPULSE_DURATION = 800;
        const IMPULSE_MAX_RADIUS = 2.5;
        const IMPULSE_RING_THICKNESS = 0.05;

        const appData = {
            spiritual: { tasks: []},
            intellect: { memory: { toLearn: [], learned: [] }, analysis: { tasks: [] }, tafakkur: { tasks: [] }},
            combat: { tasks: [] }
        };
        let nextTaskId = 0;

        let characterLevel = 0;
        let currentRank = "E";
        const POINTS_PER_LEVEL = 10;
        const rankThresholds = { E: 0, D: 5, C: 10, B: 20, A: 30, S: 50 };
        const rankColors = { E: "#718096", D: "#48BB78", C: "#4299E1", B: "#9F7AEA", A: "#ED8936", S: "#E53E3E" };

        const canvasContainer = document.getElementById('canvasContainer');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const messageArea = document.getElementById('messageArea');
        // Removed old panel toggle button
        const controlButtonGroup = document.getElementById('controlButtonGroup');
        const levelUpTextElement = document.getElementById('levelUpText');

        // Modal Toggle Buttons
        const toggleSpiritualModalBtn = document.getElementById('toggleSpiritualModalBtn');
        const toggleIntellectModalBtn = document.getElementById('toggleIntellectModalBtn');
        const toggleCombatModalBtn = document.getElementById('toggleCombatModalBtn');
        const toggleGlobalTimerBtn = document.getElementById('toggleGlobalTimerBtn');

        // Modals
        const spiritualModal = document.getElementById('spiritualModal');
        const intellectModal = document.getElementById('intellectModal');
        const combatModal = document.getElementById('combatModal');
        const globalTimerModal = document.getElementById('globalTimerModal');

        // Level/Rank displays within modals
        const levelRankDisplaySpiritual = document.getElementById('levelRankDisplaySpiritual');
        const levelRankDisplayIntellect = document.getElementById('levelRankDisplayIntellect');
        const levelRankDisplayCombat = document.getElementById('levelRankDisplayCombat');


        // Global Timer Modal Elements
        const globalTimerDisplayEl = document.getElementById('globalTimerDisplay');
        const globalTimerDurationInput = document.getElementById('globalTimerDurationInput');
        const globalTimerStartBtn = document.getElementById('globalTimerStartBtn');
        const globalTimerResetBtn = document.getElementById('globalTimerResetBtn');
        // globalTimerCloseBtn is handled by generic modal close logic

        // Attribute content areas (now inside modals, but IDs are the same for JS logic)
        // const attributeContentAreas = { // This might not be needed if we directly target modal content
        //     spiritual: document.getElementById('spiritualContent'), // This ID is now inside spiritualModal
        //     intellect: document.getElementById('intellectContent'), // This ID is now inside intellectModal
        //     combat: document.getElementById('combatContent')      // This ID is now inside combatModal
        // };

        let starryCanvas, starryCtx;
        const stars = [];
        const numStars = 200;
        let watchingEyes = [];
        const EYE_LIFETIME_MIN = 3000;
        const EYE_LIFETIME_MAX = 5000;
        const EYE_CREATION_INTERVAL_MIN = 10000;
        const EYE_CREATION_INTERVAL_MAX = 25000;
        let lastEyeCreationTime = 0;
        let nextEyeCreationDelay = Math.random() * (EYE_CREATION_INTERVAL_MAX - EYE_CREATION_INTERVAL_MIN) + EYE_CREATION_INTERVAL_MIN;

        let clock;
        let lastImpulseCreationTime = 0;
        const IMPULSE_INTERVAL = 2.0;

        function formatTime(totalSeconds) {
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        function playTimerEndSound() {
            if (typeof Tone !== 'undefined' && Tone && Tone.Synth) {
                 if (!timerSoundSynth) {
                    timerSoundSynth = new Tone.Synth({
                        oscillator: { type: "sine" },
                        envelope: { attack: 0.005, decay: 0.1, sustain: 0.01, release: 0.1 }
                    }).toDestination();
                }
                const now = Tone.now();
                timerSoundSynth.triggerAttackRelease("C5", "16n", now);
                timerSoundSynth.triggerAttackRelease("C5", "16n", now + 0.15);
                timerSoundSynth.triggerAttackRelease("G5", "8n", now + 0.3);
            } else {
                console.warn("Tone.js не загружен или Synth не доступен. Звук таймера не будет воспроизведен.");
            }
        }
        function setGlobalTimerProgress(percent) {
            if (globalTimerCircle) {
                const offset = globalTimerCircumference - (percent / 100) * globalTimerCircumference;
                globalTimerCircle.style.strokeDashoffset = offset;
            }
        }

        function updateGlobalTimerDisplay() {
            if (globalTimerDisplayEl) {
                globalTimerDisplayEl.textContent = formatTime(globalTimerRemainingSeconds);
            }
            const progressPercent = globalTimerTotalSeconds > 0 ? (globalTimerRemainingSeconds / globalTimerTotalSeconds) * 100 : 0;
            setGlobalTimerProgress(progressPercent);
        }

        function startGlobalTimer() {
            if (isGlobalTimerRunning && globalTimerRemainingSeconds > 0) {
                clearInterval(globalTimerIntervalId);
                isGlobalTimerRunning = false;
                globalTimerStartBtn.textContent = 'Продолжить';
                globalTimerStartBtn.classList.remove('running');
                globalTimerDurationInput.disabled = false;
                return;
            }

            if (typeof Tone !== 'undefined' && Tone.context.state !== 'running') {
                Tone.start().then(() => {
                    console.log("Tone.js context started by timer.");
                });
            }
            if(globalTimerRemainingSeconds === 0) {
                 globalTimerRemainingSeconds = globalTimerTotalSeconds;
            }

            isGlobalTimerRunning = true;
            globalTimerStartBtn.textContent = 'Пауза';
            globalTimerStartBtn.classList.add('running');
            globalTimerDurationInput.disabled = true;

            globalTimerIntervalId = setInterval(() => {
                globalTimerRemainingSeconds--;
                updateGlobalTimerDisplay();

                if (globalTimerRemainingSeconds <= 0) {
                    stopGlobalTimer(true);
                    playTimerEndSound();
                    showUserMessage("Таймер завершен!", "success", 3000);
                }
            }, 1000);
        }

        function stopGlobalTimer(finished = false) {
            clearInterval(globalTimerIntervalId);
            isGlobalTimerRunning = false;
            globalTimerStartBtn.textContent = 'Старт';
            globalTimerStartBtn.classList.remove('running');
            globalTimerDurationInput.disabled = false;
            if (finished) {
                globalTimerRemainingSeconds = globalTimerTotalSeconds;
                updateGlobalTimerDisplay();
            }
        }

        function resetGlobalTimer() {
            stopGlobalTimer();
            globalTimerTotalSeconds = parseInt(globalTimerDurationInput.value, 10);
             if (isNaN(globalTimerTotalSeconds) || globalTimerTotalSeconds < 1) {
                globalTimerTotalSeconds = 120;
                globalTimerDurationInput.value = globalTimerTotalSeconds;
            }
            globalTimerRemainingSeconds = globalTimerTotalSeconds;
            updateGlobalTimerDisplay();
        }


        function initStarryBackground() {
            console.log("FN_INIT_STARRY_BG: Инициализация звездного фона...");
            starryCanvas = document.getElementById('starryBackground');
            if (!starryCanvas) { console.warn("FN_INIT_STARRY_BG_WARN: Холст для звезд не найден! Фон будет темным."); return; }
            starryCtx = starryCanvas.getContext('2d');
            if (!starryCtx) { console.warn("FN_INIT_STARRY_BG_WARN: Контекст холста для звезд не найден!"); return; }

            starryCanvas.width = window.innerWidth;
            starryCanvas.height = window.innerHeight;

            for (let i = 0; i < numStars; i++) {
                stars.push({
                    x: Math.random() * starryCanvas.width,
                    y: Math.random() * starryCanvas.height,
                    radius: Math.random() * 1.2,
                    alpha: 0.5 + Math.random() * 0.5,
                    twinkleSpeed: Math.random() * 0.02 + 0.005,
                    twinklePhase: Math.random() * Math.PI * 2
                });
            }
            animateStarryBackground();
            console.log("FN_INIT_STARRY_BG: Звездный фон инициализирован.");
        }
        function animateStarryBackground() {
            if (!starryCtx || !starryCanvas) return;
            starryCtx.fillStyle = '#02030A';
            starryCtx.fillRect(0, 0, starryCanvas.width, starryCanvas.height);

            stars.forEach(star => {
                star.twinklePhase += star.twinkleSpeed;
                const currentAlpha = star.alpha * (0.6 + Math.sin(star.twinklePhase) * 0.4);

                starryCtx.beginPath();
                starryCtx.arc(star.x, star.y, star.radius, 0, Math.PI * 2, false);
                starryCtx.fillStyle = `rgba(220, 220, 255, ${currentAlpha})`;
                starryCtx.fill();
            });
            if (watchingEyes.length > 0) {
                drawWatchingEyes();
            }
            requestAnimationFrame(animateStarryBackground);
        }

        function addPlaceholderObject() {
            const geometry = new THREE.BoxGeometry(1, 1.8, 0.5);
            const material = new THREE.MeshStandardMaterial({
                color: 0x607D8B,
                roughness: 0.6,
                metalness: 0.3
            });
            const placeholder = new THREE.Mesh(geometry, material);
            placeholder.position.y = 1.8 / 2;
            scene.add(placeholder);
            loadedModel = placeholder;
            showUserMessage("3D модель не загружена. Отображается заменитель.", "warning");
            if(loadingIndicator) loadingIndicator.style.display = 'none';
        }

        function init() {
            console.log("FN_INIT: Инициализация 3D сцены...");
            if (!canvasContainer) {
                console.error("FN_INIT_ERROR: canvasContainer не найден! Прерывание инициализации.");
                showUserMessage("Критическая ошибка: контейнер для 3D не найден!", "error");
                return;
            }

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, canvasContainer.clientWidth / canvasContainer.clientHeight, 0.1, 1000);
            camera.position.set(0, 1.2, 3.2);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            canvasContainer.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
            scene.add(ambientLight);
            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight1.position.set(5, 10, 7);
            scene.add(directionalLight1);
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.7);
            directionalLight2.position.set(-5, 8, -5);
            scene.add(directionalLight2);
            const frontLight = new THREE.PointLight(0xa0c0ff, 0.6, 10);
            frontLight.position.set(0, 0.5, 3);
            scene.add(frontLight);

            intellectAuraGroup = new THREE.Group(); scene.add(intellectAuraGroup);
            combatAuraGroup = new THREE.Group();    scene.add(combatAuraGroup);
            spiritualAuraGroup = new THREE.Group(); scene.add(spiritualAuraGroup);
            groundImpulseGroup = new THREE.Group(); scene.add(groundImpulseGroup);

            clock = new THREE.Clock();

            const loader = new THREE.GLTFLoader();
            const modelUrl = 'https://firdavs39.github.io/3/scene.gltf';
            if (loadingIndicator) loadingIndicator.style.display = 'block';
            if (loadingIndicator) loadingIndicator.textContent = 'Загрузка 3D модели...';
            showUserMessage("Загрузка 3D модели...", "info");

            loader.load(modelUrl,
                function (gltf) {
                    loadedModel = gltf.scene;
                    loadedModel.name = "importedHumanoid";

                    loadedModel.traverse(function (child) {
                        if (child.isMesh) {
                            child.material = new THREE.MeshStandardMaterial({
                                color: 0x0077BE,
                                transparent: true, opacity: 0.80,
                                metalness: 0.5, roughness: 0.4,
                                emissive: 0x002244,
                                emissiveIntensity: 0.4,
                                depthWrite: true, side: THREE.DoubleSide
                            });
                        }
                    });

                    const box = new THREE.Box3().setFromObject(loadedModel);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    let scaleFactor = 1.0;
                    if (maxDim > 0.001 && isFinite(maxDim)) { scaleFactor = 1.8 / maxDim; }
                    else { scaleFactor = 0.5; }

                    loadedModel.scale.set(scaleFactor, scaleFactor, scaleFactor);
                    const scaledCenterOffset = center.clone().multiplyScalar(scaleFactor);
                    loadedModel.position.sub(scaledCenterOffset);

                    const finalBox = new THREE.Box3().setFromObject(loadedModel);
                    loadedModel.position.y -= finalBox.min.y;

                    scene.add(loadedModel);
                    if(loadingIndicator) loadingIndicator.style.display = 'none';
                    showUserMessage("Модель загружена.", "success");

                    if (controls) {
                        const worldBox = new THREE.Box3().setFromObject(loadedModel);
                        const worldModelCenter = worldBox.getCenter(new THREE.Vector3());
                        controls.target.copy(worldModelCenter);
                    }
                },
                (xhr) => {
                    if (loadingIndicator) {
                        if (xhr.lengthComputable && xhr.total > 0) {
                            loadingIndicator.textContent = `Загрузка: ${Math.round(xhr.loaded / xhr.total * 100)}%`;
                        } else {
                            loadingIndicator.textContent = `Загружено: ${Math.round(xhr.loaded / 1024)} KB`;
                        }
                    }
                },
                (error) => {
                    console.error('Ошибка загрузки 3D модели:', error);
                    if(loadingIndicator) {
                         loadingIndicator.innerHTML = 'Ошибка загрузки 3D модели!<br>Проверьте консоль (F12) и URL модели.';
                         loadingIndicator.style.color = '#FF5555';
                    }
                    showUserMessage('Ошибка загрузки 3D модели! Проверьте консоль (F12).', 'error');
                    addPlaceholderObject();
                }
            );

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 0.5; controls.maxDistance = 20;

            window.addEventListener('resize', onWindowResize, false);
            setupEventListeners();
            updateCharacterLevelAndRank(); // Initial call
            animate();

            try { initStarryBackground(); } catch(e) { console.error("Ошибка инициализации звездного фона:", e); }

            // switchAttributeContent('intellect'); // No default panel to open
            console.log("FN_INIT: Инициализация завершена.");
        };

        onWindowResize = function() {
            if (!canvasContainer || !renderer || !camera) return;

            const newWidth = canvasContainer.clientWidth;
            const newHeight = canvasContainer.clientHeight;

            if (newWidth === 0 || newHeight === 0) {
                console.warn("onWindowResize: Ширина или высота контейнера равна нулю.");
                return;
            }

            camera.aspect = newWidth / newHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(newWidth, newHeight);

            if (starryCanvas) {
                starryCanvas.width = window.innerWidth;
                starryCanvas.height = window.innerHeight;
            }
            if (renderer && scene && camera) { renderer.render(scene, camera); }
        };

        animate = function() {
            requestAnimationFrame(animate);
            if (controls) controls.update();

            const elapsedTime = clock.getElapsedTime();
            const deltaTime = clock.getDelta();

            if (loadedModel && elapsedTime - lastImpulseCreationTime > IMPULSE_INTERVAL) {
                createGroundImpulse();
                lastImpulseCreationTime = elapsedTime;
            }

            animateIntellectAura();
            animateCombatAura();
            animateSpiritualAura();
            animateGroundImpulses();
            animateWatchingEyes(deltaTime);

            if (renderer && scene && camera) { renderer.render(scene, camera); }
        };

        const impulseVertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const impulseFragmentShader = `
            varying vec2 vUv;
            uniform float uProgress;
            uniform vec3 uColor;
            uniform float uRingFalloff;
            uniform float uOverallAlpha;

            void main() {
                float radialIntensity = pow(1.0 - vUv.y, uRingFalloff);
                float alpha = uOverallAlpha * radialIntensity * (1.0 - pow(uProgress, 2.0));
                gl_FragColor = vec4(uColor, alpha);
            }
        `;

        function createGroundImpulse() {
            if (!loadedModel || !groundImpulseGroup) return;

            const modelBox = new THREE.Box3().setFromObject(loadedModel);
            const modelBaseY = modelBox.min.y;

            const impulseGeometry = new THREE.RingGeometry(
                0.01, IMPULSE_MAX_RADIUS, 64, 1, 0, Math.PI * 2
            );

            const impulseMaterial = new THREE.ShaderMaterial({
                vertexShader: impulseVertexShader,
                fragmentShader: impulseFragmentShader,
                uniforms: {
                    uProgress: { value: 0.0 },
                    uColor: { value: IMPULSE_COLOR },
                    uRingFalloff: { value: 2.5 },
                    uOverallAlpha: { value: 0.8 }
                },
                transparent: true,
                side: THREE.DoubleSide,
                depthWrite: false
            });

            const impulseMesh = new THREE.Mesh(impulseGeometry, impulseMaterial);
            impulseMesh.position.set(loadedModel.position.x, modelBaseY + 0.01, loadedModel.position.z);
            impulseMesh.rotation.x = -Math.PI / 2;
            impulseMesh.scale.set(0.01, 0.01, 0.01);

            impulseMesh.userData = {
                startTime: clock.getElapsedTime(),
                duration: IMPULSE_DURATION,
                maxRadiusScale: 1.0
            };

            groundImpulseGroup.add(impulseMesh);
        }

        function animateGroundImpulses() {
            if (!groundImpulseGroup) return;
            const currentTime = clock.getElapsedTime();

            for (let i = groundImpulseGroup.children.length - 1; i >= 0; i--) {
                const impulse = groundImpulseGroup.children[i];
                const elapsedTimeSinceStart = currentTime - impulse.userData.startTime;
                let progress = elapsedTimeSinceStart / (impulse.userData.duration / 1000);

                if (progress >= 1.0) {
                    groundImpulseGroup.remove(impulse);
                    impulse.geometry.dispose();
                    impulse.material.dispose();
                    continue;
                }

                progress = Math.min(progress, 1.0);

                const currentScale = progress * impulse.userData.maxRadiusScale;
                impulse.scale.set(currentScale, currentScale, currentScale);

                impulse.material.uniforms.uProgress.value = progress;
                impulse.material.uniforms.uOverallAlpha.value = 0.8 * (1.0 - Math.pow(progress, 2.5));
            }
        }

        createLightningBolt = function(group) {
            if (!loadedModel) return;

            const points = [];
            const modelBox = new THREE.Box3().setFromObject(loadedModel);
            const modelSize = modelBox.getSize(new THREE.Vector3());
            const modelCenter = modelBox.getCenter(new THREE.Vector3());

            const radiusScale = 0.55 + Math.random() * 0.2;
            const radius = Math.max(modelSize.x, modelSize.y, modelSize.z) * radiusScale;
            const phi = Math.random() * Math.PI * 2;
            const theta = Math.acos((Math.random() * 2) - 1);

            const startPos = new THREE.Vector3(
                radius * Math.sin(theta) * Math.cos(phi),
                radius * Math.sin(theta) * Math.sin(phi),
                radius * Math.cos(theta)
            ).add(modelCenter);
            points.push(startPos);

            let currentPos = startPos.clone();
            const numSegments = 4 + Math.floor(Math.random() * 5);
            createBranch(points, currentPos, numSegments, 1 + Math.floor(Math.random()*2) );

            if (points.length < 2) return;

            const isBrightBolt = Math.random() < 0.25;
            let boltColor = AURA_BOLT_COLOR_BASE.clone();
            let boltLinewidth = 0.8 + Math.random() * 1.2;
            let boltOpacity = 0.4 + Math.random() * 0.4;

            if (isBrightBolt) {
                boltColor = AURA_BOLT_COLOR_BRIGHT.clone();
                boltLinewidth = 1.8 + Math.random() * 1.5;
                boltOpacity = 0.7 + Math.random() * 0.3;
            }

            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
                color: boltColor,
                linewidth: boltLinewidth,
                transparent: true,
                opacity: boltOpacity
            });
            const bolt = new THREE.Line(geometry, material);
            bolt.userData.life = AURA_BOLT_LIFETIME * (0.7 + Math.random() * 0.6) ;
            bolt.userData.originalPositions = geometry.attributes.position.clone();
            bolt.userData.isBright = isBrightBolt;

            if(group) group.add(bolt);
            else console.warn("createLightningBolt: группа для добавления молнии не определена");
        };

        createBranch = function(pointsArray, startPoint, segments, depth) {
            if (depth <= 0) return;

            let current = startPoint.clone();
            const segmentLengthBase = (0.1 + Math.random() * 0.15) / (depth);

            for (let i = 0; i < segments; i++) {
                const segmentLength = segmentLengthBase * (0.7 + Math.random() * 0.6);
                const deviationAngle = Math.PI / 3;

                let direction;
                if (pointsArray.length > 1) {
                    direction = new THREE.Vector3().subVectors(pointsArray[pointsArray.length-1], pointsArray[pointsArray.length-2]).normalize();
                } else {
                    direction = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize();
                }

                const randomRotation = new THREE.Euler(
                    (Math.random() - 0.5) * deviationAngle,
                    (Math.random() - 0.5) * deviationAngle,
                    (Math.random() - 0.5) * deviationAngle
                );
                direction.applyEuler(randomRotation).multiplyScalar(segmentLength);

                const next = current.clone().add(direction);
                pointsArray.push(next);

                if (Math.random() < (0.5 / depth) && i < segments -1 && depth > 1) {
                    createBranch(pointsArray, next, Math.max(1, segments - 2), depth -1);
                     pointsArray.push(next);
                }
                current = next;
            }
        };

        function updateIntellectAura(points = 1) {
            currentIntellectPoints += points;
            currentIntellectPoints = Math.max(0, currentIntellectPoints);
            updateCharacterLevelAndRank();
        }

        function animateIntellectAura() {
             if (!intellectAuraGroup || !loadedModel) return;

            for (let i = intellectAuraGroup.children.length - 1; i >= 0; i--) {
                const bolt = intellectAuraGroup.children[i];
                bolt.userData.life -= 16;
                if (bolt.userData.life <= 0) {
                    intellectAuraGroup.remove(bolt);
                    bolt.geometry.dispose();
                    bolt.material.dispose();
                } else {
                    const lifeRatio = bolt.userData.life / AURA_BOLT_LIFETIME;
                    bolt.material.opacity = (bolt.userData.isBright ? 0.7 + 0.3 * Math.random() : 0.4 + 0.4 * Math.random()) * lifeRatio;
                    const positions = bolt.geometry.attributes.position;
                    const originalPositions = bolt.userData.originalPositions;
                    const jitterAmount = (bolt.userData.isBright ? 0.05 : 0.035) * lifeRatio;
                    for (let j = 0; j < positions.count; j++) {
                        const currentJitter = (j > 0 && j < positions.count -1) ? jitterAmount : jitterAmount * 0.3;
                        positions.setXYZ(
                            j,
                            originalPositions.getX(j) + (Math.random() - 0.5) * currentJitter,
                            originalPositions.getY(j) + (Math.random() - 0.5) * currentJitter,
                            originalPositions.getZ(j) + (Math.random() - 0.5) * currentJitter
                        );
                    }
                    positions.needsUpdate = true;
                 }
            }

            const targetBoltCount = Math.floor(currentIntellectPoints * 2);
            const currentBoltCount = intellectAuraGroup.children.length;
            const boltsToActuallyAdd = Math.min(2, targetBoltCount - currentBoltCount);

            if (currentBoltCount < Math.min(targetBoltCount, MAX_TOTAL_BOLTS) && boltsToActuallyAdd > 0) {
                for(let k=0; k < boltsToActuallyAdd ; k++){
                     createLightningBolt(intellectAuraGroup);
                }
            }
        };

        let currentCombatLevel = 0;

        function handleCombatTaskCountChange(taskId, newCountString) {
            const task = appData.combat.tasks.find(t => t.id == taskId);
            if (!task) return;

            const newCount = parseInt(newCountString, 10);
            if (isNaN(newCount) || newCount < 0) {
                const inputElement = document.querySelector(`.task-counter-input[data-task-id="${taskId}"][data-attribute="combat"]`);
                if (inputElement) inputElement.value = task.count;
                return;
            }

            const oldCount = task.count;
            const diff = newCount - oldCount;
            task.count = newCount;

            if (diff > 0) {
                for (let i = 0; i < diff; i++) { createFlameParticle(); }
            } else if (diff < 0) {
                const particlesToRemove = Math.abs(diff);
                for (let i = 0; i < particlesToRemove && combatAuraGroup.children.length > 0; i++) {
                    const particleToRemove = combatAuraGroup.children[combatAuraGroup.children.length - 1 - i];
                    if (particleToRemove) {
                         combatAuraGroup.remove(particleToRemove);
                         particleToRemove.geometry.dispose();
                         if (particleToRemove.material.map) particleToRemove.material.map.dispose();
                         particleToRemove.material.dispose();
                    }
                }
            }
            recalculateAndDisplayCombatLevel();
            updateCharacterLevelAndRank();
        }

        function recalculateAndDisplayCombatLevel() {
            let totalCombatPoints = 0;
            appData.combat.tasks.forEach(task => {
                totalCombatPoints += parseInt(task.count, 10) || 0;
            });
            currentCombatLevel = totalCombatPoints;
            showUserMessage(`Аура Силы: ${currentCombatLevel.toFixed(0)}`, "success", 1000);
        }

        createFlameParticle = function() {
            if (!loadedModel || !combatAuraGroup) return;

            const modelBox = new THREE.Box3().setFromObject(loadedModel);
            const modelCenter = modelBox.getCenter(new THREE.Vector3());
            const modelSize = modelBox.getSize(new THREE.Vector3());
            const modelBaseY = modelCenter.y - modelSize.y * 0.5;
            const modelHeadY = modelCenter.y + modelSize.y * 0.4;

            const particleGeometry = new THREE.BufferGeometry();
            const particleMaterial = new THREE.PointsMaterial({
                size: 0.08 + Math.random() * 0.04,
                map: createFlameTexture(false),
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.85, // Initial opacity
                vertexColors: true
            });

            const startY = modelBaseY + Math.random() * 0.2;
            const startRadius = modelSize.x * 0.25 + Math.random() * modelSize.x * 0.15;
            const startAngle = Math.random() * Math.PI * 2;

            const position = new Float32Array([
                modelCenter.x + Math.cos(startAngle) * startRadius,
                startY,
                modelCenter.z + Math.sin(startAngle) * startRadius
            ]);
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(position, 3));

            const flameColor = new THREE.Color().lerpColors(FLAME_COLOR_START, FLAME_COLOR_END, Math.random());
            const colors = new Float32Array([flameColor.r, flameColor.g, flameColor.b]);
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));


            const particle = new THREE.Points(particleGeometry, particleMaterial);
            particle.userData = {
                velocity: new THREE.Vector3(
                    (Math.random() - 0.5) * 0.003,
                    0.020 + Math.random() * 0.012,
                    (Math.random() - 0.5) * 0.003
                ),
                initialY: startY,
                initialOpacity: particleMaterial.opacity, // Store initial opacity
                initialSize: particleMaterial.size,
                maxHeight: modelHeadY + modelSize.y * 0.6,
                modelCenter: modelCenter.clone(),
                baseRadius: startRadius,
                initialColor: flameColor.clone(),
                modelSizeY: modelSize.y // Store modelSize.y for fade calculation
            };
            if (combatAuraGroup) combatAuraGroup.add(particle);
        };

        createFlameTexture = function(isWhite = false) {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const context = canvas.getContext('2d');

            const gradient = context.createRadialGradient(
                canvas.width / 2, canvas.height / 2, 0,
                canvas.width / 2, canvas.height / 2, canvas.width / 2
            );

            if (isWhite) {
                gradient.addColorStop(0, 'rgba(255,255,255,1)');
                gradient.addColorStop(0.3, 'rgba(255,255,255,0.8)');
                gradient.addColorStop(0.7, 'rgba(255,255,255,0.3)');
                gradient.addColorStop(1, 'rgba(255,255,255,0)');
            } else {
                gradient.addColorStop(0, 'rgba(255,255,200,1)');
                gradient.addColorStop(0.2, 'rgba(255,200,0,1)');
                gradient.addColorStop(0.5, 'rgba(255,100,0,0.8)');
                gradient.addColorStop(0.8, 'rgba(255,0,0,0.5)');
                gradient.addColorStop(1, 'rgba(150,0,0,0)');
            }

            context.fillStyle = gradient;
            context.fillRect(0, 0, canvas.width, canvas.height);
            return new THREE.CanvasTexture(canvas);
        };

        animateCombatAura = function() {
            if (!combatAuraGroup || !loadedModel) return;

            for (let i = combatAuraGroup.children.length - 1; i >= 0; i--) {
                const particle = combatAuraGroup.children[i];
                const userData = particle.userData;
                const fadeStartHeight = userData.maxHeight - (userData.modelSizeY * 0.25);

                particle.position.add(userData.velocity);

                if (particle.position.y > userData.maxHeight) {
                    particle.position.y = userData.initialY;
                    const resetAngle = Math.random() * Math.PI * 2;
                    const resetRadius = userData.baseRadius * (0.8 + Math.random() * 0.4);
                    particle.position.x = userData.modelCenter.x + Math.cos(resetAngle) * resetRadius;
                    particle.position.z = userData.modelCenter.z + Math.sin(resetAngle) * resetRadius;
                    particle.material.opacity = userData.initialOpacity;
                    particle.material.size = userData.initialSize;
                    if (particle.geometry.attributes.color && userData.initialColor) {
                        const colors = particle.geometry.attributes.color;
                        colors.setXYZ(0, userData.initialColor.r, userData.initialColor.g, userData.initialColor.b);
                        colors.needsUpdate = true;
                    }
                    userData.velocity.y = 0.020 + Math.random() * 0.012;
                } else if (particle.position.y > fadeStartHeight) {
                    const fadeProgress = (particle.position.y - fadeStartHeight) / (userData.maxHeight - fadeStartHeight);
                    particle.material.opacity = userData.initialOpacity * (1 - Math.min(1, Math.max(0, fadeProgress)));
                } else {
                     particle.material.opacity = userData.initialOpacity;
                }
            }
        };

        let currentSpiritualLevel = 0;

        function handleSpiritualTaskCountChange(taskId, newCountString) {
            const task = appData.spiritual.tasks.find(t => t.id == taskId);
            if (!task) return;

            const newCount = parseInt(newCountString, 10);
            if (isNaN(newCount) || newCount < 0) {
                const inputElement = document.querySelector(`.task-counter-input[data-task-id="${taskId}"][data-attribute="spiritual"]`);
                if (inputElement) inputElement.value = task.count;
                return;
            }

            const oldCount = task.count;
            const diff = newCount - oldCount;
            task.count = newCount;

            if (diff > 0) {
                for (let i = 0; i < diff; i++) {
                    createSpiritParticle();
                }
            } else if (diff < 0) {
                const particlesToRemove = Math.abs(diff);
                 for (let i = 0; i < particlesToRemove && spiritualAuraGroup.children.length > 0; i++) {
                    const particleToRemove = spiritualAuraGroup.children[spiritualAuraGroup.children.length - 1 - i];
                     if (particleToRemove) {
                         spiritualAuraGroup.remove(particleToRemove);
                         particleToRemove.geometry.dispose();
                         if (particleToRemove.material.map) particleToRemove.material.map.dispose();
                         particleToRemove.material.dispose();
                     }
                }
            }
            recalculateAndDisplaySpiritualLevel();
            updateCharacterLevelAndRank();
        }

        function recalculateAndDisplaySpiritualLevel() {
            let totalSpiritualPoints = 0;
            appData.spiritual.tasks.forEach(task => {
                totalSpiritualPoints += parseInt(task.count, 10) || 0;
            });
            currentSpiritualLevel = totalSpiritualPoints;
            showUserMessage(`Аура Духовности: ${currentSpiritualLevel.toFixed(0)}`, "success", 1000);
        }

        createSpiritParticle = function() {
            if (!loadedModel || !spiritualAuraGroup) return;

            const modelBox = new THREE.Box3().setFromObject(loadedModel);
            const modelCenter = modelBox.getCenter(new THREE.Vector3());
            const modelSize = modelBox.getSize(new THREE.Vector3());
            const modelBaseY = modelCenter.y - modelSize.y * 0.5;
            const modelHeadY = modelCenter.y + modelSize.y * 0.4;

            const particleGeometry = new THREE.BufferGeometry();
            const particleMaterial = new THREE.PointsMaterial({
                size: 0.07 + Math.random() * 0.03,
                map: createFlameTexture(true),
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.85, // Initial opacity
                color: SPIRIT_COLOR,
                vertexColors: false
            });

            const startY = modelBaseY + Math.random() * 0.2;
            const startRadius = modelSize.x * 0.2 + Math.random() * modelSize.x * 0.1;
            const startAngle = Math.random() * Math.PI * 2;

            const position = new Float32Array([
                modelCenter.x + Math.cos(startAngle) * startRadius,
                startY,
                modelCenter.z + Math.sin(startAngle) * startRadius
            ]);
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(position, 3));

            const particle = new THREE.Points(particleGeometry, particleMaterial);

            particle.userData = {
                velocity: new THREE.Vector3(
                    (Math.random() - 0.5) * 0.0025,
                    0.018 + Math.random() * 0.01,
                    (Math.random() - 0.5) * 0.0025
                ),
                initialY: startY,
                initialOpacity: particleMaterial.opacity, // Store initial opacity
                initialSize: particleMaterial.size,
                maxHeight: modelHeadY + modelSize.y * 0.6,
                modelCenter: modelCenter.clone(),
                baseRadius: startRadius,
                modelSizeY: modelSize.y // Store modelSize.y for fade calculation
            };

            if(spiritualAuraGroup) spiritualAuraGroup.add(particle);
        };

        animateSpiritualAura = function() {
            if (!spiritualAuraGroup || !loadedModel) return;

            for (let i = spiritualAuraGroup.children.length - 1; i >= 0; i--) {
                const particle = spiritualAuraGroup.children[i];
                const userData = particle.userData;
                const fadeStartHeight = userData.maxHeight - (userData.modelSizeY * 0.25); // Start fading in the last 25%

                particle.position.add(userData.velocity);

                if (particle.position.y > userData.maxHeight) {
                    particle.position.y = userData.initialY;
                    const resetAngle = Math.random() * Math.PI * 2;
                    const resetRadius = userData.baseRadius * (0.8 + Math.random() * 0.4);
                    particle.position.x = userData.modelCenter.x + Math.cos(resetAngle) * resetRadius;
                    particle.position.z = userData.modelCenter.z + Math.sin(resetAngle) * resetRadius;
                    particle.material.opacity = userData.initialOpacity; // Reset opacity
                    particle.material.size = userData.initialSize;
                    userData.velocity.y = 0.018 + Math.random() * 0.01;
                } else if (particle.position.y > fadeStartHeight) {
                    const fadeProgress = (particle.position.y - fadeStartHeight) / (userData.maxHeight - fadeStartHeight);
                    particle.material.opacity = userData.initialOpacity * (1 - Math.min(1, Math.max(0, fadeProgress)));
                } else {
                     particle.material.opacity = userData.initialOpacity;
                }
            }
        };

        function updateCharacterLevelAndRank() {
            let totalPointsForLevelCalc = 0;

            appData.spiritual.tasks.forEach(task => totalPointsForLevelCalc += task.count);
            appData.combat.tasks.forEach(task => totalPointsForLevelCalc += task.count);
            appData.intellect.memory.toLearn.forEach(task => totalPointsForLevelCalc += task.count);
            appData.intellect.memory.learned.forEach(task => totalPointsForLevelCalc += 1);
            appData.intellect.analysis.tasks.forEach(task => totalPointsForLevelCalc += task.count);
            appData.intellect.tafakkur.tasks.forEach(task => totalPointsForLevelCalc += task.count);

            const newLevel = Math.floor(totalPointsForLevelCalc / POINTS_PER_LEVEL);

            if (newLevel > characterLevel) {
                showLevelUpAnimation();
            }
            characterLevel = newLevel;

            let newRank = "E";
            if (characterLevel >= rankThresholds.S) newRank = "S";
            else if (characterLevel >= rankThresholds.A) newRank = "A";
            else if (characterLevel >= rankThresholds.B) newRank = "B";
            else if (characterLevel >= rankThresholds.C) newRank = "C";
            else if (characterLevel >= rankThresholds.D) newRank = "D";
            currentRank = newRank;

            // Update level display in all relevant places (modals)
            const rankHTML = `Уровень: ${characterLevel} (<span class="rank-${currentRank}">Ранг: ${currentRank}</span>)`;
            if(levelRankDisplaySpiritual) levelRankDisplaySpiritual.innerHTML = rankHTML;
            if(levelRankDisplayIntellect) levelRankDisplayIntellect.innerHTML = rankHTML;
            if(levelRankDisplayCombat) levelRankDisplayCombat.innerHTML = rankHTML;
        }

        function showLevelUpAnimation() {
            if (levelUpTextElement) {
                levelUpTextElement.classList.add('show');
                setTimeout(() => {
                    levelUpTextElement.classList.remove('show');
                }, 2000);
            }
            if (loadedModel && loadedModel.isGroup) {
                const originalEmissiveIntensity = {};
                loadedModel.traverse(child => {
                    if (child.isMesh && child.material && child.material.emissive) {
                        originalEmissiveIntensity[child.uuid] = child.material.emissiveIntensity;
                        child.material.emissiveIntensity = 2.5;
                    }
                });
                setTimeout(() => {
                    loadedModel.traverse(child => {
                        if (child.isMesh && child.material && child.material.emissive) {
                            child.material.emissiveIntensity = originalEmissiveIntensity[child.uuid] !== undefined ? originalEmissiveIntensity[child.uuid] : 0.4;
                        }
                    });
                }, 300);
            }
        }

        function createWatchingEye() {
            if (!starryCanvas || !starryCtx) return;

            const eye = {
                x: Math.random() * starryCanvas.width,
                y: Math.random() * (starryCanvas.height * 0.6),
                radius: 10 + Math.random() * 10,
                pupilRadius: 3 + Math.random() * 3,
                color: `rgba(200, 0, 0, 0)`,
                targetAlpha: 0.5 + Math.random() * 0.3,
                currentAlpha: 0,
                life: EYE_LIFETIME_MIN + Math.random() * (EYE_LIFETIME_MAX - EYE_LIFETIME_MIN),
                startTime: clock.getElapsedTime(),
                state: 'appearing'
            };
            watchingEyes.push(eye);
        }

        function drawWatchingEyes() {
            if (!starryCtx) return;
            watchingEyes.forEach(eye => {
                starryCtx.beginPath();
                starryCtx.arc(eye.x, eye.y, eye.radius, 0, Math.PI * 2);
                starryCtx.fillStyle = `rgba(150, 0, 0, ${eye.currentAlpha * 0.7})`;
                starryCtx.fill();
                starryCtx.beginPath();
                starryCtx.arc(eye.x, eye.y, eye.pupilRadius, 0, Math.PI * 2);
                starryCtx.fillStyle = `rgba(255, 20, 20, ${eye.currentAlpha})`;
                starryCtx.fill();
            });
        }

        function animateWatchingEyes(deltaTime) {
            if (!starryCtx) return;

            const currentTime = clock.getElapsedTime();

            if (currentTime - lastEyeCreationTime > nextEyeCreationDelay / 1000) {
                createWatchingEye();
                lastEyeCreationTime = currentTime;
                nextEyeCreationDelay = Math.random() * (EYE_CREATION_INTERVAL_MAX - EYE_CREATION_INTERVAL_MIN) + EYE_CREATION_INTERVAL_MIN;
            }

            for (let i = watchingEyes.length - 1; i >= 0; i--) {
                const eye = watchingEyes[i];
                const timeAlive = (currentTime - eye.startTime) * 1000;

                if (timeAlive > eye.life) {
                    watchingEyes.splice(i, 1);
                    continue;
                }

                if (eye.state === 'appearing') {
                    eye.currentAlpha += deltaTime * 2;
                    if (eye.currentAlpha >= eye.targetAlpha) {
                        eye.currentAlpha = eye.targetAlpha;
                        eye.state = 'visible';
                    }
                } else if (eye.state === 'visible') {
                    if (timeAlive > eye.life * 0.7) {
                        eye.state = 'fading';
                    }
                } else if (eye.state === 'fading') {
                    eye.currentAlpha -= deltaTime * 1.5;
                    if (eye.currentAlpha <= 0) {
                        eye.currentAlpha = 0;
                    }
                }
                eye.currentAlpha = Math.max(0, Math.min(eye.targetAlpha, eye.currentAlpha));
            }
        }


        renderTasks = function(taskListId, tasks, attributeType, subCategory = null) {
            const taskListDiv = document.getElementById(taskListId);
            if (!taskListDiv) {
                console.warn(`renderTasks: Элемент списка ${taskListId} не найден.`);
                return;
            }
            taskListDiv.innerHTML = '';
            tasks.forEach(task => {
                const itemDiv = document.createElement('div');
                itemDiv.className = `task-item`;

                let counterElement;

                if (attributeType === 'spiritual' || attributeType === 'combat' || (attributeType === 'intellect' && subCategory !== 'memoryLearned')) {
                    counterElement = `
                        <input type="number" class="task-counter-input"
                               value="${task.count}"
                               min="0"
                               data-task-id="${task.id}"
                               data-attribute="${attributeType}"
                               ${subCategory ? `data-subcategory="${subCategory}"` : ''}>
                    `;
                } else {
                    counterElement = `<span class="task-counter">${task.count}</span>`;
                }

                itemDiv.innerHTML = `
                    <span class="task-text flex-grow">${task.text}</span>
                    <div class="task-controls">
                        <div class="task-counter-group">
                            ${counterElement}
                            <button class="plus-btn" data-task-id="${task.id}" data-attribute="${attributeType}" ${subCategory ? `data-subcategory="${subCategory}"` : ''}>+</button>
                        </div>
                        <button class="delete-task-btn" data-task-id="${task.id}" data-attribute="${attributeType}" ${subCategory ? `data-subcategory="${subCategory}"` : ''} title="Удалить задачу">&times;</button>
                    </div>
                `;
                taskListDiv.appendChild(itemDiv);
            });
        };

        renderMemoryLearned = function(listId, items) {
             const listDiv = document.getElementById(listId);
               if (!listDiv) {
                console.warn(`renderMemoryLearned: Элемент списка ${listId} не найден.`);
                return;
            }
            listDiv.innerHTML = '';
            items.forEach(item => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'memory-item';
                itemDiv.innerHTML = `
                    <span class="flex-grow">${item.text}</span>
                    <button class="delete-item-btn" data-item-id="${item.id}" title="Удалить">&times;</button>
                `;
                listDiv.appendChild(itemDiv);
            });
        };

        // No longer switching content in a single panel, but opening modals
        // switchAttributeContent is effectively replaced by modal open/close logic

        function openModal(modalElement) {
            if (modalElement) {
                modalElement.classList.add('open');
                // Refresh content if needed when opening
                const attributeType = modalElement.id.replace('Modal', ''); // e.g., "spiritual"
                if (attributeType === 'spiritual') renderTasks('spiritualTaskList', appData.spiritual.tasks, 'spiritual');
                else if (attributeType === 'intellect') switchIntellectTab('memory'); // Default to memory tab
                else if (attributeType === 'combat') renderTasks('combatTaskList', appData.combat.tasks, 'combat');
                updateCharacterLevelAndRank(); // Update rank display in the opened modal
            }
        }

        function closeModal(modalElement) {
            if (modalElement) {
                modalElement.classList.remove('open');
            }
        }


        setupEventListeners = function() {
            // Event listeners for new attribute modal toggles
            if (toggleSpiritualModalBtn) toggleSpiritualModalBtn.onclick = () => openModal(spiritualModal);
            if (toggleIntellectModalBtn) toggleIntellectModalBtn.onclick = () => openModal(intellectModal);
            if (toggleCombatModalBtn) toggleCombatModalBtn.onclick = () => openModal(combatModal);

            // Event listeners for modal close buttons
            document.querySelectorAll('.modal-close-btn').forEach(btn => {
                btn.onclick = () => {
                    const modalId = btn.dataset.modalId;
                    const modalToClose = document.getElementById(modalId);
                    if (modalToClose) {
                        if (modalId === 'globalTimerModal') stopGlobalTimer(); // Stop timer if closing its modal
                        closeModal(modalToClose);
                    }
                };
            });
            // Close modal if clicked on backdrop
            document.querySelectorAll('.modal-backdrop').forEach(backdrop => {
                backdrop.onclick = (event) => {
                    if (event.target === backdrop) {
                        if (backdrop.id === 'globalTimerModal') stopGlobalTimer();
                        closeModal(backdrop);
                    }
                };
            });


            // Global Timer Button Listener
            if (toggleGlobalTimerBtn && globalTimerModal) {
                toggleGlobalTimerBtn.onclick = () => {
                    globalTimerModal.classList.add('open');
                    let currentDuration = parseInt(globalTimerDurationInput.value, 10);
                     if (isNaN(currentDuration) || currentDuration < 1) {
                        currentDuration = 120;
                        globalTimerDurationInput.value = currentDuration;
                    }
                    globalTimerTotalSeconds = currentDuration;
                    globalTimerRemainingSeconds = currentDuration;
                    updateGlobalTimerDisplay();
                     if (typeof Tone !== 'undefined' && Tone.context.state !== 'running') {
                        Tone.start().then(() => console.log("Tone.js context started by opening timer modal."));
                    }
                };
            }
            if (globalTimerStartBtn) {
                globalTimerStartBtn.onclick = () => {
                    if (isGlobalTimerRunning) {
                        stopGlobalTimer();
                    } else {
                        startGlobalTimer();
                    }
                };
            }
            if (globalTimerResetBtn) {
                globalTimerResetBtn.onclick = resetGlobalTimer;
            }

             if (globalTimerDurationInput) {
                globalTimerDurationInput.onchange = () => {
                    if (!isGlobalTimerRunning) {
                        let newDuration = parseInt(globalTimerDurationInput.value, 10);
                        if (isNaN(newDuration) || newDuration < 1) {
                            newDuration = 120;
                            globalTimerDurationInput.value = newDuration;
                        }
                        globalTimerTotalSeconds = newDuration;
                        globalTimerRemainingSeconds = newDuration;
                        updateGlobalTimerDisplay();
                    } else {
                        globalTimerDurationInput.value = globalTimerTotalSeconds;
                    }
                };
            }

            if (globalTimerCircle) {
                globalTimerCircle.style.strokeDasharray = `${globalTimerCircumference} ${globalTimerCircumference}`;
                setGlobalTimerProgress(100);
            }


            document.querySelectorAll('.intellect-tabs button').forEach(tabBtn => {
                tabBtn.onclick = () => switchIntellectTab(tabBtn.dataset.tab);
            });

            setupTaskAddition('addSpiritualTaskBtn', 'newSpiritualTaskInput', appData.spiritual.tasks, 'spiritualTaskList', 'spiritual');
            setupTaskAddition('addCombatTaskBtn', 'newCombatTaskInput', appData.combat.tasks, 'combatTaskList', 'combat');
            setupTaskAddition('addMemoryToLearnBtn', 'newMemoryToLearnInput', appData.intellect.memory.toLearn, 'memoryToLearnList', 'intellect', 'memory');

            const addMemoryLearnedBtn = document.getElementById('addMemoryLearnedBtn');
            if(addMemoryLearnedBtn) addMemoryLearnedBtn.onclick = () => {
                const input = document.getElementById('newMemoryLearnedInput');
                if(!input) return;
                const text = input.value.trim();
                if (text) {
                    appData.intellect.memory.learned.push({ id: `learned-${nextTaskId++}`, text: text, count: 1 });
                    renderMemoryLearned('memoryLearnedList', appData.intellect.memory.learned);
                    input.value = '';
                    updateIntellectAura(1);
                    updateCharacterLevelAndRank();
                }
            };
            const memoryLearnedListEl = document.getElementById('memoryLearnedList');
            if(memoryLearnedListEl) memoryLearnedListEl.addEventListener('click', (event) => {
                if (event.target.classList.contains('delete-item-btn')) {
                    const itemId = event.target.dataset.itemId;
                    const itemIndex = appData.intellect.memory.learned.findIndex(item => item.id === itemId);
                    if (itemIndex > -1) {
                        appData.intellect.memory.learned.splice(itemIndex, 1);
                        renderMemoryLearned('memoryLearnedList', appData.intellect.memory.learned);
                        updateIntellectAura(-1);
                        updateCharacterLevelAndRank();
                    }
                }
            });

            setupTaskAddition('addAnalysisTaskBtn', 'newAnalysisTaskInput', appData.intellect.analysis.tasks, 'analysisTaskList', 'intellect', 'analysis');
            setupTaskAddition('addTafakkurTaskBtn', 'newTafakkurTaskInput', appData.intellect.tafakkur.tasks, 'tafakkurTaskList', 'intellect', 'tafakkur');

            document.body.addEventListener('click', function(event) {
                if (event.target.classList.contains('plus-btn')) {
                    const taskId = event.target.dataset.taskId;
                    const attribute = event.target.dataset.attribute;
                    const subCategory = event.target.dataset.subcategory;

                    let taskArray;
                    if (attribute === 'spiritual') taskArray = appData.spiritual.tasks;
                    else if (attribute === 'combat') taskArray = appData.combat.tasks;
                    else if (attribute === 'intellect') {
                        if (subCategory === 'memory') taskArray = appData.intellect.memory.toLearn;
                        else if (subCategory === 'analysis') taskArray = appData.intellect.analysis.tasks;
                        else if (subCategory === 'tafakkur') taskArray = appData.intellect.tafakkur.tasks;
                    }

                    const task = taskArray ? taskArray.find(t => t.id == taskId) : null;
                    if (task) {
                        const newCount = task.count + 1;
                        if (attribute === 'spiritual') handleSpiritualTaskCountChange(taskId, newCount.toString());
                        else if (attribute === 'combat') handleCombatTaskCountChange(taskId, newCount.toString());
                        else if (attribute === 'intellect') {
                            task.count = newCount;
                            updateIntellectAura(1);
                            updateCharacterLevelAndRank();
                            const inputElement = document.querySelector(`#intellectModal .task-counter-input[data-task-id="${taskId}"][data-attribute="intellect"][data-subcategory="${subCategory}"]`);
                            if (inputElement) inputElement.value = newCount;
                        }
                        const inputElementGeneral = document.querySelector(`.task-counter-input[data-task-id="${taskId}"][data-attribute="${attribute}"]` + (subCategory && attribute !== 'intellect' ? `[data-subcategory="${subCategory}"]` : ''));
                         if (inputElementGeneral) inputElementGeneral.value = newCount;
                    }
                } else if (event.target.classList.contains('delete-task-btn')) {
                    const taskId = event.target.dataset.taskId;
                    const attribute = event.target.dataset.attribute;
                    const subCategory = event.target.dataset.subcategory;

                    let taskArray;
                    let particleGroup;
                    let listId;
                    let pointsToSubtractFromIntellect = 0;


                    if (attribute === 'spiritual') {
                        taskArray = appData.spiritual.tasks;
                        particleGroup = spiritualAuraGroup;
                        listId = 'spiritualTaskList';
                    } else if (attribute === 'combat') {
                        taskArray = appData.combat.tasks;
                        particleGroup = combatAuraGroup;
                        listId = 'combatTaskList';
                    } else if (attribute === 'intellect' && subCategory) {
                        if (subCategory === 'memory') taskArray = appData.intellect.memory.toLearn;
                        else if (subCategory === 'analysis') taskArray = appData.intellect.analysis.tasks;
                        else if (subCategory === 'tafakkur') taskArray = appData.intellect.tafakkur.tasks;
                        listId = subCategory === 'memory' ? 'memoryToLearnList' : (subCategory === 'analysis' ? 'analysisTaskList' : 'tafakkurTaskList');
                    } else { return; }

                    const taskIndex = taskArray.findIndex(t => t.id == taskId);
                    if (taskIndex > -1) {
                        const removedTask = taskArray[taskIndex];
                        const particlesToRemoveCount = removedTask.count;
                        if (attribute === 'intellect') {
                            pointsToSubtractFromIntellect = removedTask.count;
                        }
                        taskArray.splice(taskIndex, 1);

                        if (particleGroup && (attribute === 'spiritual' || attribute === 'combat')) {
                            for (let i = 0; i < particlesToRemoveCount && particleGroup.children.length > 0; i++) {
                                const particleToRemove = particleGroup.children[particleGroup.children.length - 1];
                                if (particleToRemove) {
                                    particleGroup.remove(particleToRemove);
                                    particleToRemove.geometry.dispose();
                                    if (particleToRemove.material.map) particleToRemove.material.map.dispose();
                                    particleToRemove.material.dispose();
                                }
                            }
                        }
                        if (attribute === 'intellect') {
                            updateIntellectAura(-pointsToSubtractFromIntellect);
                        }
                        renderTasks(listId, taskArray, attribute, subCategory);
                        updateCharacterLevelAndRank();
                    }
                }
            });
            document.body.addEventListener('change', function(event) {
                const target = event.target;
                if (target.classList.contains('task-counter-input')) {
                    const taskId = target.dataset.taskId;
                    const attribute = target.dataset.attribute;
                    const subCategory = target.dataset.subcategory;

                    if (attribute === 'spiritual') {
                        handleSpiritualTaskCountChange(taskId, target.value);
                    } else if (attribute === 'combat') {
                        handleCombatTaskCountChange(taskId, target.value);
                    } else if (attribute === 'intellect' && subCategory && subCategory !== 'memoryLearned') {
                        const taskArray = subCategory === 'memory' ? appData.intellect.memory.toLearn :
                                          subCategory === 'analysis' ? appData.intellect.analysis.tasks :
                                          appData.intellect.tafakkur.tasks;
                        const task = taskArray.find(t => t.id == taskId);
                        if (task) {
                            const newCount = parseInt(target.value, 10);
                             if (!isNaN(newCount) && newCount >= 0) {
                                const diff = newCount - task.count;
                                task.count = newCount;
                                updateIntellectAura(diff);
                                updateCharacterLevelAndRank();
                             } else {
                                target.value = task.count;
                             }
                        }
                    }
                }
            });
        };

        setupTaskAddition = function(addBtnId, inputId, taskArray, listId, attributeType, subCategory = null) {
            const addBtn = document.getElementById(addBtnId);
            const inputEl = document.getElementById(inputId);
            if (!addBtn || !inputEl) {
                console.warn(`setupTaskAddition: Отсутствуют элементы для добавления задачи: ${addBtnId}, ${inputId}`);
                return;
            }

            addBtn.onclick = () => {
                const text = inputEl.value.trim();
                if (text) {
                    const newTask = { id: nextTaskId++, text: text, count: 0 };
                    taskArray.push(newTask);
                    renderTasks(listId, taskArray, attributeType, subCategory);
                    updateCharacterLevelAndRank();
                    inputEl.value = '';
                }
            };
        };

        switchIntellectTab = function(tabName) {
            document.querySelectorAll('#intellectModal .intellect-tabs button').forEach(btn => btn.classList.remove('active-tab'));
            document.querySelectorAll('#intellectModal .intellect-tab-content').forEach(content => content.style.display = 'none'); // Hide all first

            const activeTabButton = document.querySelector(`#intellectModal .intellect-tabs button[data-tab="${tabName}"]`);
            const activeTabContent = document.getElementById(`${tabName}TabContent`);

            if (activeTabButton) activeTabButton.classList.add('active-tab');
            if (activeTabContent) activeTabContent.style.display = 'block'; // Show active

            if (tabName === 'memory') {
                renderTasks('memoryToLearnList', appData.intellect.memory.toLearn, 'intellect', 'memory');
                renderMemoryLearned('memoryLearnedList', appData.intellect.memory.learned);
            } else if (tabName === 'analysis') {
                renderTasks('analysisTaskList', appData.intellect.analysis.tasks, 'intellect', 'analysis');
            } else if (tabName === 'tafakkur') {
                renderTasks('tafakkurTaskList', appData.intellect.tafakkur.tasks, 'intellect', 'tafakkur');
            }
            updateCharacterLevelAndRank();
        };

        let messageTimeout;
        showUserMessage = function(message, type = 'info', duration = 3000) {
            if (messageArea) {
                messageArea.textContent = message;
                messageArea.className = 'show'; // Base class to make it visible

                // Add type-specific color classes
                if (type === 'success') messageArea.classList.add('text-green-400', 'bg-green-900', 'bg-opacity-50');
                else if (type === 'error') messageArea.classList.add('text-red-400', 'bg-red-900', 'bg-opacity-50');
                else if (type === 'warning') messageArea.classList.add('text-yellow-400', 'bg-yellow-900', 'bg-opacity-50');
                else messageArea.classList.add('text-sky-400', 'bg-sky-900', 'bg-opacity-50'); // Default info

                clearTimeout(messageTimeout);
                if (duration > 0) {
                    messageTimeout = setTimeout(() => {
                        messageArea.classList.remove('show');
                    }, duration);
                }
            } else {
                console.log(`Сообщение (${type}): ${message}`);
            }
        };


        window.onload = function() {
            console.log("Событие window.onload. v9.69 (Глобальный Таймер UI Update)");
            try {
                init();
            } catch (e) {
                console.error("КРИТИЧЕСКАЯ ОШИБКА ПРИ ЗАГРУЗКЕ:", e);
                const ld = document.getElementById('loadingIndicator');
                if (ld) {
                    ld.innerHTML = 'КРИТИЧЕСКАЯ ОШИБКА!<br>См. консоль (F12).';
                    ld.style.color = 'red';
                    ld.style.display = 'block';
                }
            }
        };
        console.log("Выполнение скрипта завершено. v9.69 (Глобальный Таймер UI Update)");
    </script>
</body>
</html>
